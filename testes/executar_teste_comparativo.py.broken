import asyncio
import websockets
import ssl
import json
import os
import wave
import csv
import sys
from datetime import datetime

# --- Configura√ß√µes ---
# Se o servidor estiver rodando em outra porta ou host, ajuste aqui.
WS_URL = "wss://balto.pbpmdev.com/ws/debug_audio"
ADMIN_SECRET = "x9PeHTY7ouQNvzJH" # Default do .env, pode alterar se necess√°rio

# Diret√≥rios
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
INPUT_DIR = os.path.join(BASE_DIR, "audios_para_teste")

# Nome do Relat√≥rio
TIMESTAMP = datetime.now().strftime("%Y%m%d_%H%M%S")
OUTPUT_CSV = os.path.join(BASE_DIR, f"relatorio_comparativo_{TIMESTAMP}.csv")

# Configura√ß√£o de Streaming (Otimizado para Baixo CPU)
CHUNK_SIZE_MS = 100 # Aumentado de 20ms para 100ms para reduzir overhead
SAMPLE_RATE = 16000
BYTES_PER_SAMPLE = 2 # 16-bit
# (16000 samples/s * 2 bytes/sample * 0.02s) = 640 bytes
CHUNK_SIZE_BYTES = int(SAMPLE_RATE * BYTES_PER_SAMPLE * (CHUNK_SIZE_MS / 1000))


def get_audio_stream(file_path):
    """
    Generator que l√™ o arquivo como bytes brutos (Raw File) para enviar ao servidor.
    O servidor (FFMPEG) deve ser capaz de detectar o formato (WebM, WAV, etc).
    """
    try:
        with open(file_path, 'rb') as f:
            while True:
                data = f.read(4096)
                if not data:
                    break
                yield data
    except Exception as e:
        print(f"      ‚ùå Erro ao ler arquivo {file_path}: {e}")
        return


# Vari√°vel global para rastrear qual arquivo est√° sendo enviado no momento (para logs)
CURRENT_FILENAME = "Iniciando..."

async def enviar_audios_continuos(ws, files):
    """
    Envia todos os arquivos da lista sequencialmente pela mesma conex√£o WebSocket.
    """
    global CURRENT_FILENAME
    
    for i, file_name in enumerate(files):
        CURRENT_FILENAME = file_name
        file_path = os.path.join(INPUT_DIR, file_name)
        print(f"\nüéß [{i+1}/{len(files)}] Enviando streaming: {file_name}")

        if not os.path.exists(file_path):
            print(f"‚ùå Arquivo n√£o encontrado: {file_path}")
            continue

        # Usando o generator que suporta WebM/WAV
        audio_generator = get_audio_stream(file_path)
        
        bytes_buffer = bytearray()
        total_sent = 0
        
        for block in audio_generator:
            bytes_buffer.extend(block)
            
            # Enquanto tiver dados suficientes para um chunk de envio
            while len(bytes_buffer) >= CHUNK_SIZE_BYTES:
                chunk = bytes_buffer[:CHUNK_SIZE_BYTES]
                bytes_buffer = bytes_buffer[CHUNK_SIZE_BYTES:]
                
                await ws.send(chunk)
                total_sent += len(chunk)
                # Sleep ligeiramente maior que o tempo real para dar f√¥lego ao sistema
                await asyncio.sleep((CHUNK_SIZE_MS / 1000) * 1.1) 

        # Enviar sobras
        if len(bytes_buffer) > 0:
            await ws.send(bytes_buffer)
            total_sent += len(bytes_buffer)

        print(f"   üì§ Enviado: {total_sent} bytes. Inserindo pausa longa (10s)...")
        
        # Pausa maior entre arquivos para liberar CPU
        silence_duration_ms = 10000
        silence_bytes = int(SAMPLE_RATE * BYTES_PER_SAMPLE * (silence_duration_ms / 1000))
        silence_chunk = b'\x00' * silence_bytes
        
        # Enviar sil√™ncio parcelado tamb√©m para manter o "real-time"
        chunk_silence = 3200 # 100ms
        for j in range(0, len(silence_chunk), chunk_silence):
             await ws.send(silence_chunk[j:j+chunk_silence])
             await asyncio.sleep(0.01) # R√°pido, s√≥ pra n√£o travar buffer

    CURRENT_FILENAME = "Finalizado"
    print("\n‚úÖ Todos os arquivos foram enviados. Aguardando √∫ltimos eventos...")
    # Aguarda um pouco extra para garantir que o √∫ltimo processamento chegue
    await asyncio.sleep(5.0)


async def main():
    print("üöÄ Iniciando Teste Comparativo Cont√≠nuo (Single Connection)")
    print(f"üìÅ Pasta de Entrada: {INPUT_DIR}")
    print(f"üìÑ Arquivo de Sa√≠da: {OUTPUT_CSV}")
    print(f"üîó URL: {WS_URL}")

    # Verificar pasta de entrada
    if not os.path.exists(INPUT_DIR):
        print(f"‚ùå Diret√≥rio de entrada n√£o encontrado: {INPUT_DIR}")
        return

    files = sorted([f for f in os.listdir(INPUT_DIR) if not f.startswith('.')])
    if not files:
        print("‚ùå Nenhum arquivo encontrado.")
        return

    print(f"üìä Encontrados {len(files)} arquivos para processar na sess√£o.")

    # Preparar CSV
    headers = [
        "Arquivo_Origem", "Segmento_ID", "Duracao_(s)", 
        "Routing_Model", "Routing_Reason",
        "Transcricao_ElevenLabs", "Transcricao_AssemblyAI",
        "Recomendacao_Produto", "Confianca", "Explicacao_IA"
    ]

    segments_data = {}

    try:
    try:
        async with websockets.connect(
            WS_URL + f"?key={ADMIN_SECRET}",
            ping_interval=30,
            ping_timeout=60
        ) as ws:
            extra_headers=extra_headers,
            ping_interval=30,
            ping_timeout=60
        ) as ws:
            print("   ‚úÖ Conectado ao WebSocket de Debug")

            # Inicia Listener em Background
            receber_task = asyncio.create_task(receber_eventos(ws, segments_data))

            # Inicia Envio Sequencial
            await enviar_audios_continuos(ws, files)

            # Cancela listener ao fim
            receber_task.cancel()
            
    except Exception as e:
        print(f"\n‚ùå Erro Fatal na Conex√£o: {e}")
    
    # Salvar Relat√≥rio Final
    print("üíæ Salvando relat√≥rio...")
    with open(OUTPUT_CSV, mode='w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(headers)
        
        # O listener popular 'segments_data', agora precisamos salvar
        # O 'salvar_resultados' antigo salvava por arquivo, agora salvamos tudo
        count = 0
        for seg_id, data in segments_data.items():
            analysis = data.get("analysis", {})
            transcriptions = data.get("transcriptions", {})
            routing = data.get("routing", {})
            
            writer.writerow([
                data.get("source_file", "Unknown"), # Capturado pelo listener via global
                seg_id,
                f"{data.get('duration', 0):.2f}",
                routing.get("selected_model", "N/A"),
                routing.get("reason", "N/A"),
                transcriptions.get("elevenlabs", ""),
                transcriptions.get("assemblyai", ""),
                analysis.get("produto", ""),
                analysis.get("confianca", ""),
                analysis.get("explicacao", "")
            ])
            count += 1
            
        print(f"üìù {count} segmentos registrados no relat√≥rio.")

    print(f"‚úÖ Teste conclu√≠do. Relat√≥rio: {OUTPUT_CSV}")



async def receber_eventos(ws, segments_data):
    """
    Loop que fica ouvindo o WebSocket e populando o dicion√°rio segments_data.
    """
    try:
        while True:
            msg = await ws.recv()
            data = json.loads(msg)
            
            # Extrair event_type e event_payload do JSON recebido
            event_type = data.get("event", "unknown")
            event_payload = data.get("data", {})
            
            print(f"      üì• Evento recebido: {event_type}")
            
            seg_id = event_payload.get("segment_id")
            
            if event_type == "segment_created":
                if not seg_id:
                    # Fallback se n√£o vier ID
                    seg_id = f"unknown_{len(segments_data)}"
                
                segments_data[seg_id] = {
                    "id": seg_id,
                    "source_file": CURRENT_FILENAME, # Captura o arquivo tocando AGORA
                    "duration": event_payload.get("duration_seconds", 0),
                    "routing": {},
                    "transcriptions": {},
                    "analysis": {},
                    "raw_events": []
                }
                print(f"      üîπ Segmento detectado: {seg_id} ({event_payload.get('duration_seconds')}s)")

            elif seg_id and seg_id in segments_data:
                # Eventos subsequentes para um segmento conhecido
                if event_type == "routing_decision":
                    segments_data[seg_id]["routing"] = event_payload
                
                elif event_type == "transcription_result":
                    segments_data[seg_id]["transcriptions"] = event_payload.get("transcriptions", {})
                    segments_data[seg_id]["chosen_stt"] = event_payload.get("chosen_for_analysis")

                elif event_type == "analysis_result":
                    segments_data[seg_id]["analysis"] = event_payload.get("analysis", {})
                    print(f"      ‚ú® An√°lise conclu√≠da para {seg_id}")
            
            else:
                 print(f"      ‚ùì Evento ignorado ou ID ausente: {event_type} - ID: {seg_id}")

    except websockets.exceptions.ConnectionClosed:
        print("   üîå Conex√£o fechada pelo servidor.")





if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüõë Teste interrompido pelo usu√°rio.")
    except ConnectionRefusedError:
        print(f"\n‚ùå Falha na conex√£o: N√£o foi poss√≠vel conectar a {WS_URL}")
        print("Verifique se o servidor Balto est√° rodando e se a porta est√° correta.")
